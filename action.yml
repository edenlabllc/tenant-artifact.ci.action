name: Create and upload tenant Artifact
description: Create and upload tenant Artifact to S3 specific bucket by semver.

inputs:
  autotag:
    description: Enable auto tagging when merging into target branch.
    required: false
    default: false
  github_token_repo_full_access:
    description: GitHub token with full access permissions to repositories.
    required: true
    default: ""
  core_aws_region:
    description: AWS region of the AWS account storing artifact in S3.
    required: true
  core_aws_access_key_id:
    description: AWS access key ID of the AWS account storing artifact in S3.
    required: true
  core_aws_secret_key:
    description: AWS secret access key of the AWS account storing artifact in S3.
    required: true
  tarball_version:
    description: Artifact release version, mandatory in semver mode.
    required: false
  rmk_version:
    description: EKS cluster name of the AWS account deploying applications to EKS.
    required: false
    default: latest
  rmk_release_skip_context_switch:
    description: Skip context switch for not provisioned cluster.
    required: false
    default: true
  skip_generate_certs_linkerd:
    description: Skip generate certs linkerd for not provisioned cluster.
    required: false
    default: true
  custom_tenant_name:
    description: Custom Tenant name for different client repo.
    required: false
  include_paths:
    description: |
      List of files and directories that will be included in the distribution archive.
      Example:
      include_paths: .deps .helmfile docs etc helmfile.yaml README.md version.yaml
    required: false
    default: ".deps .helmfile docs etc helmfile.yaml README.md version.yaml"

runs:
  using: composite
  steps:
    - run: |
        set -e
        
        export GITHUB_TOKEN='${{ inputs.github_token_repo_full_access }}'
        export AWS_REGION='${{ inputs.core_aws_region }}'
        export AWS_ACCESS_KEY_ID='${{ inputs.core_aws_access_key_id }}'
        export AWS_SECRET_ACCESS_KEY='${{ inputs.core_aws_secret_key }}'
        export RMK_RELEASE_SKIP_CONTEXT_SWITCH='${{ inputs.rmk_release_skip_context_switch }}'
        export SKIP_GENERATE_CERTS_LINKERD='${{ inputs.skip_generate_certs_linkerd }}'
        
        readonly AUTOTAG='${{ inputs.autotag }}'
        readonly RMK_VERSION='${{ inputs.rmk_version }}'
        readonly CUSTOM_TENANT_NAME='${{ inputs.custom_tenant_name }}'
        readonly INCLUDE_PATHS=(${{ inputs.include_paths }})
        readonly DIST_DIR="dist"
        readonly DIST_TMP_DIR="${DIST_DIR}/tmp"
        readonly DIST_ARCHIVE_DIR="${DIST_DIR}/archive"
        readonly DIST_EXCLUDE_FILES="${DIST_DIR}/exclude_files"
        
        TARBALL_VERSION='${{ inputs.tarball_version }}'
        
        if [[ "${AUTOTAG}" == "true" ]]; then
          GITHUB_ORG="${GITHUB_REPOSITORY%%/*}"
          
          if [[ "${GITHUB_REF}" != refs/heads/* ]]; then
            >&2 echo "Only pushes to branches are supported. Check the workflow's on.push.* section."
            exit 1
          fi
        
          GIT_BRANCH="${GITHUB_REF#refs/heads/}"
        
          echo "Git commit message: $(git log -1 --pretty=format:"%s")"
          GIT_COMMIT_MSG="$(git log -1 --pretty=format:"%s")"
        
          function check_commit() {
            if [[ ! "${GIT_COMMIT_MSG}" =~ ^Merge\ pull\ request\ #[0-9]+\ from\ ${GITHUB_ORG}/${1}(v[0-9]+\.[0-9]+\.[0-9]+)-${GIT_BRANCH}$ ]]; then
              >&2 echo "Pushes to ${GIT_BRANCH} should be done via merges of PR requests from ${1}vN.N.N-${GIT_BRANCH} branches only."
              >&2 echo "The expected message format (will be used for parsing a release tag):"
              >&2 echo "Merge pull request #N from ${GITHUB_ORG}/${1}vN.N.N-${GIT_BRANCH}"
              exit 1
            fi
          }

          case "${GIT_BRANCH}" in
            develop)
              check_commit "feature/"
              ;;
            staging)
              check_commit "release/"
              ;;
            production)
              check_commit ""
              ;;
          esac
        
          TARBALL_VERSION="${BASH_REMATCH[1]}-${GIT_BRANCH}"
        
          git tag "${TARBALL_VERSION}"
          git push origin "${TARBALL_VERSION}"
        fi
        
        if [[ -z "${TARBALL_VERSION}" ]]; then
          >&2 echo "ERROR: Failed to get tarball version from branch name or input parameter"
          exit 1
        fi
        
        echo
        echo "Install RMK."
        curl -sL "https://edenlabllc-rmk-tools-infra.s3.eu-north-1.amazonaws.com/rmk/s3-installer" | bash -s -- "${RMK_VERSION}"
        rmk --version
        
        function rmk_get_dependencies() {
          rmk config init --progress-bar=false --sops-age-keys-download=false
          mkdir -p sops-age-keys
          touch sops-age-keys/.keys.txt
          rmk release list 1> /dev/null
        }
        
        function create_dir() {
          rm -rf "${DIST_DIR}"
          mkdir -p "${DIST_TMP_DIR}"
          mkdir -p "${DIST_ARCHIVE_DIR}"
          echo ">INFO: created ${DIST_DIR} dirs."
        }
        
        function prepare_gitignore() {
          cat <<EOF > "${DIST_TMP_DIR}"/.gitignore
        .DS_Store
        .idea/
        .env
        **.dec
        sops-age-keys/
        dist/
        EOF
          echo ">INFO: prepare .gitignore file for new artifact."
        }
        
        function prepare_exclude_files() {
          ls etc/*/*/secrets/*.yaml > "${DIST_EXCLUDE_FILES}"
        }
        
        function get_include_path() {
          ARCHIVE_LIST=""
          for ITEM in "${INCLUDE_PATHS[@]}"; do
            if [[ -d "${ITEM}" ]]; then
              ARCHIVE_LIST="${ARCHIVE_LIST}${ITEM}/ "
            else
              ARCHIVE_LIST="${ARCHIVE_LIST}${ITEM} "
            fi
          done
        
          echo "${ARCHIVE_LIST}"
        }
        
        function upload_artifact() {
          if [[ -z "${CUSTOM_TENANT_NAME}" ]]; then
            TENANT_NAME="$(rmk config view | tail +2 | yq '.tenant')"
          else
            TENANT_NAME="${CUSTOM_TENANT_NAME}"
          fi
        
          local BUCKET_NAME="edenlabllc-${TENANT_NAME}-artifacts-infra"
          tar --version 
          tar --exclude '*.git' --exclude-from "${DIST_EXCLUDE_FILES}" \
          -zcvf "${DIST_ARCHIVE_DIR}/${TENANT_NAME}-${TARBALL_VERSION}".tar.gz $(get_include_path) \
          -C "${DIST_TMP_DIR}"/ .
          echo ">INFO: create tarball with version ${TARBALL_VERSION} by path ${DIST_ARCHIVE_DIR}."
          echo ">INFO: start upload on s3 bucket: ${BUCKET_NAME}"
          aws s3 sync "${DIST_ARCHIVE_DIR}" s3://"${BUCKET_NAME}"/"${TARBALL_VERSION}" --delete
        }
        
        # download all rmk dependencies by version.yaml
        rmk_get_dependencies
        # create DIST dir for artifact
        create_dir
        prepare_gitignore
        prepare_exclude_files
        upload_artifact
      shell: bash
